# -*- coding: utf-8 -*-
"""Digits Recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BI_RNy8feJOEPU1MKdXPXq5WZwRF-R7J
"""

import os
import cv2
import numpy as np
import tensorflow as tf
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.models import Sequential
from tensorflow.keras.datasets import mnist
from tensorflow.keras.utils import normalize
import matplotlib.pyplot as plt

#load data
(xtrain, ytrain), (xtest,ytest)=mnist.load_data()
mnist

#Normalize the data..Rescales pixel values to a range between 0 and 1 for easier training.
xtrain= normalize(xtrain, axis=1)
xtest= normalize(xtest, axis=1)

model=Sequential()
model.add(Flatten(input_shape=(28,28))) #Flattening transforms the 2D feature maps into a 1D vector to input into the dense layers.
model.add(Dense(128,activation='relu'))
model.add(Dense(128,activation='relu'))
model.add(Dense(10,activation='softmax')) #output layer

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy',metrics=['accuracy'])
# train the model
model.fit(xtrain,ytrain, epochs=3)

#evaluate the model
loss, accuracy=model.evaluate(xtest, ytest)
print(f"Loss: {loss}")
print(f"Accuracy: {accuracy}")

# Make predictions on digit files

 #Load the image in grayscale mode and resize if necessary so it has only one channel insted of 3
img=cv2.imread(r"/content/image3.png", cv2.IMREAD_GRAYSCALE)

# Resizing to 28x28 if needed
img = cv2.resize(img, (28, 28))

# Invert colors, expand dimensions, and normalize
img=np.invert(img)           # turning dark pixels into light pixels and vice versa.
img = img.reshape(1, 28, 28)  # Add batch dimension
img = normalize(img,axis=1)  # Normalize to match model's expected input range

#predict
prediction=model.predict(img)
print(f"This digit is probably {np.argmax(prediction,axis=1)}")

#Display the image
plt.imshow(img[0], cmap=plt.cm.binary)
plt.show()